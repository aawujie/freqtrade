# Freqtrade策略编写完全指南

## 📋 目录

- 策略参数识别机制
- 策略的必要参数 vs 自定义参数
- 基于模板编写自己的策略
- 编写对应的Hyperopt Loss函数
- 实战案例：从零开始创建策略

## 🔍 策略参数识别机制

### 1. 参数是如何被识别的？

当你运行 `freqtrade hyperopt-show` 或使用 `freqtrade hyperopt` 时，Freqtrade通过以下机制识别策略中的参数：

```python
# 在策略类中定义的参数
class MyStrategy(IStrategy):
    # 基础参数（必要参数）
    INTERFACE_VERSION = 3
    timeframe = "5m"
    minimal_roi = {"0": 0.05}
    stoploss = -0.05

    # 可优化参数（使用Parameter类）
    buy_rsi = IntParameter(low=20, high=40, default=30, space="buy", optimize=True, load=True)
    sell_rsi = IntParameter(low=60, high=80, default=70, space="sell", optimize=True, load=True)

    # 固定参数（不会被优化）
    can_short = False
    process_only_new_candles = True
```

### 2. 不同参数类型的识别

#### IntParameter（整数参数）
```python
buy_rsi = IntParameter(
    low=20,          # 最小值
    high=40,         # 最大值
    default=30,      # 默认值
    space="buy",     # 参数空间（buy/sell/stop）
    optimize=True,   # 是否参与优化
    load=True        # 是否从JSON加载
)
```

#### DecimalParameter（小数参数）
```python
stoploss = DecimalParameter(
    low=-0.3,
    high=-0.05,
    default=-0.1,
    space="stop",
    optimize=True,
    load=True
)
```

#### CategoricalParameter（分类参数）
```python
timeframe = CategoricalParameter(
    ["5m", "15m", "1h"],  # 候选值列表
    default="5m",
    space="buy",
    optimize=True,
    load=True
)
```

### 3. 参数空间 (space) 的作用

```python
# buy空间：用于买入信号的参数
buy_rsi = IntParameter(..., space="buy")

# sell空间：用于卖出信号的参数
sell_rsi = IntParameter(..., space="sell")

# stop空间：用于止损的参数
stoploss = DecimalParameter(..., space="stop")
```

**识别机制**：Freqtrade通过反射机制扫描策略类中所有以 `Parameter` 结尾的属性。

## 📊 策略的必要参数 vs 自定义参数

### 1. 必要参数（必须定义）

#### 基础配置参数
```python
class MyStrategy(IStrategy):
    # 必须：接口版本
    INTERFACE_VERSION = 3

    # 必须：时间周期
    timeframe = "5m"

    # 必须：最小收益目标
    minimal_roi = {
        "60": 0.02,   # 60分钟内获利2%
        "30": 0.03,   # 30分钟内获利3%
        "0": 0.05     # 立即获利5%
    }

    # 必须：止损设置
    stoploss = -0.05  # 5%止损

    # 可选：是否允许做空
    can_short = False
```

#### 核心方法（必须实现）
```python
def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
    """计算技术指标"""
    return dataframe

def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
    """生成买入信号"""
    return dataframe

def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
    """生成卖出信号"""
    return dataframe
```

### 2. 可选参数（可以自定义）

#### 交易控制参数
```python
# 最大同时持仓数量
max_open_trades = 3

# 是否只在新的K线产生信号
process_only_new_candles = True

# 退出信号设置
use_exit_signal = True
exit_profit_only = False
ignore_roi_if_entry_signal = False
```

#### 订单类型设置
```python
order_types = {
    "entry": "limit",        # 入场订单类型
    "exit": "limit",         # 出场订单类型
    "stoploss": "market",    # 止损订单类型
    "stoploss_on_exchange": False  # 是否在交易所设置止损
}

order_time_in_force = {
    "entry": "GTC",  # Good Till Cancel
    "exit": "GTC"
}
```

#### 追踪止损参数
```python
# 启用追踪止损
trailing_stop = False
trailing_only_offset_is_reached = False
trailing_stop_positive = 0.01
trailing_stop_positive_offset = 0.0
```

### 3. 可优化参数（自定义参数）

这些参数使用 `Parameter` 类定义，可以通过 Hyperopt 自动优化：

#### Parameter参数详解

```python
# 完整参数定义格式
parameter_name = ParameterType(
    low=最小值,           # 参数的最小值
    high=最大值,          # 参数的最大值
    default=默认值,       # 没有优化时的默认值
    space="参数空间",     # buy/sell/stop
    optimize=True,        # ⚠️ 关键参数：是否参与Hyperopt优化
    load=True             # 是否从JSON文件加载优化结果
)
```

#### optimize参数的含义 ⭐

**`optimize=True`** 是让参数能够被 Hyperopt 自动优化的关键开关：

```python
# ✅ 可被优化的参数
buy_rsi = IntParameter(20, 40, 30, space="buy", optimize=True, load=True)
# 在Hyperopt运行时，这个参数的值会在20-40之间自动搜索最优值

# ❌ 不会被优化的参数
buy_rsi = IntParameter(20, 40, 30, space="buy", optimize=False, load=True)
# 这个参数始终使用默认值30，Hyperopt不会改变它
```

#### 不同优化状态的对比

| 参数状态 | optimize | load | Hyperopt行为 | 实际效果 |
|---------|----------|------|-------------|----------|
| **可优化** | `True` | `True` | 自动搜索最优值 | 值在low-high区间变化 |
| **固定参数** | `False` | `True` | 使用默认值 | 值始终为default |
| **调试参数** | `True` | `False` | 优化但不保存 | 只在当前运行有效 |

#### 实际使用示例

```python
# RSI相关参数
buy_rsi = IntParameter(20, 40, 30, space="buy", optimize=True, load=True)
sell_rsi = IntParameter(60, 80, 70, space="sell", optimize=True, load=True)

# 移动平均线参数
ema_short = IntParameter(5, 20, 10, space="buy", optimize=True, load=True)
ema_long = IntParameter(20, 50, 30, space="buy", optimize=True, load=True)

# 布林带参数
bb_window = IntParameter(15, 25, 20, space="buy", optimize=True, load=True)
bb_std = DecimalParameter(1.8, 2.5, 2.0, space="buy", optimize=True, load=True)

# 固定参数（不想优化的）
rsi_period = 14  # 固定RSI周期，不参与优化
```

#### 优化策略建议

1. **核心参数**：设置 `optimize=True`，让Hyperopt重点优化
2. **经验参数**：如果你有丰富的经验，可以设置 `optimize=False` 使用固定值
3. **测试参数**：新添加的参数先设 `optimize=True` 测试效果
4. **组合优化**：不要让所有参数都可优化，适当固定一些参数减少搜索空间

```python
# 推荐的优化策略
class MyStrategy(IStrategy):
    # 核心交易参数 - 重点优化
    buy_rsi = IntParameter(25, 35, 30, space="buy", optimize=True, load=True)
    sell_rsi = IntParameter(65, 75, 70, space="sell", optimize=True, load=True)

    # 技术指标参数 - 适度优化
    ema_short = IntParameter(8, 15, 12, space="buy", optimize=True, load=True)
    ema_long = IntParameter(25, 35, 30, space="buy", optimize=True, load=True)

    # 固定参数 - 基于经验确定
    rsi_period = 14  # RSI周期固定为14
    volume_multiplier = 1.5  # 成交量倍数固定
```

## 🛠️ 基于模板编写自己的策略

### 步骤1：复制模板文件

```bash
cp user_data/strategies/sample_strategy.py user_data/strategies/my_strategy.py
```

### 步骤2：修改策略名称和基本信息

```python
# 修改类名
class MyRSIStrategy(IStrategy):  # 从 SampleStrategy 改为 MyRSIStrategy
    """
    基于RSI的交易策略
    买入：RSI < 30
    卖出：RSI > 70
    """

    # 修改策略元数据
    INTERFACE_VERSION = 3
    timeframe = "15m"  # 从5分钟改为15分钟
    can_short = False  # 不允许做空

    # 修改收益目标
    minimal_roi = {
        "120": 0.01,   # 2小时内获利1%
        "60": 0.02,    # 1小时内获利2%
        "30": 0.03,    # 30分钟内获利3%
        "0": 0.05      # 立即获利5%
    }

    # 修改止损
    stoploss = -0.08  # 8%止损
```

### 步骤3：定义可优化参数

```python
# RSI参数
buy_rsi_threshold = IntParameter(
    low=25, high=35, default=30,
    space="buy", optimize=True, load=True
)

sell_rsi_threshold = IntParameter(
    low=65, high=75, default=70,
    space="sell", optimize=True, load=True
)

# 确认指标参数
ema_period = IntParameter(
    low=10, high=30, default=20,
    space="buy", optimize=True, load=True
)

# 成交量过滤
min_volume_multiplier = DecimalParameter(
    low=1.0, high=3.0, default=1.5,
    space="buy", optimize=True, load=True
)
```

### 步骤4：实现技术指标计算

```python
def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
    """计算技术指标"""

    # RSI指标
    dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)

    # EMA指标（用于趋势确认）
    dataframe['ema'] = ta.EMA(dataframe, timeperiod=self.ema_period.value)

    # 布林带（用于波动率判断）
    bollinger = qtpylib.bollinger_bands(
        qtpylib.typical_price(dataframe),
        window=20, stds=2
    )
    dataframe['bb_upper'] = bollinger['upper']
    dataframe['bb_lower'] = bollinger['lower']
    dataframe['bb_middle'] = bollinger['mid']

    # 平均成交量
    dataframe['volume_mean'] = dataframe['volume'].rolling(window=20).mean()

    return dataframe
```

### 步骤5：实现买入逻辑

```python
def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
    """生成买入信号"""

    dataframe.loc[
        (
            # 主要信号：RSI超卖
            (dataframe['rsi'] < self.buy_rsi_threshold.value)

            # 趋势确认：价格在EMA上方（上涨趋势）
            & (dataframe['close'] > dataframe['ema'])

            # 波动率确认：价格接近下轨（有反弹空间）
            & (dataframe['close'] < dataframe['bb_middle'])

            # 成交量确认：成交量放大
            & (dataframe['volume'] > dataframe['volume_mean'] * self.min_volume_multiplier.value)

            # 确保成交量不为0
            & (dataframe['volume'] > 0)
        ),
        'enter_long'
    ] = 1

    return dataframe
```

### 步骤6：实现卖出逻辑

```python
def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
    """生成卖出信号"""

    dataframe.loc[
        (
            # 主要信号：RSI超买
            (dataframe['rsi'] > self.sell_rsi_threshold.value)

            # 或者价格触及上轨（获利了结）
            | (dataframe['close'] > dataframe['bb_upper'])
        ),
        'exit_long'
    ] = 1

    return dataframe
```

### 步骤7：添加辅助方法（可选）

```python
def informative_pairs(self):
    """定义额外的参考数据"""
    return [
        ("BTC/USDT", "1h"),  # 比特币1小时数据作为参考
        ("ETH/USDT", "1h"),  # 以太坊1小时数据作为参考
    ]

def leverage(self, pair: str, current_time: datetime, current_rate: float,
             proposed_leverage: float, max_leverage: float, entry_tag: Optional[str],
             side: str, **kwargs) -> float:
    """自定义杠杆设置"""
    return 1.0  # 使用1倍杠杆（现货交易）
```

## 🎯 编写对应的Hyperopt Loss函数

### 1. 理解Loss函数的作用

Loss函数用于量化策略的"好坏"程度：

```python
# Freqtrade默认的Loss函数逻辑：
# 1. 计算总利润
# 2. 计算交易次数
# 3. 计算平均持仓时间
# 4. 综合评分（越小越好）
```

### 2. 自定义Loss函数模板

```python
from datetime import datetime
from math import exp
from pandas import DataFrame
from freqtrade.constants import Config
from freqtrade.optimize.hyperopt import IHyperOptLoss

class MyCustomHyperOptLoss(IHyperOptLoss):
    """
    自定义的Hyperopt Loss函数
    目标：平衡利润、风险和交易频率
    """

    @staticmethod
    def hyperopt_loss_function(
        results: DataFrame,
        trade_count: int,
        min_date: datetime,
        max_date: datetime,
        config: Config,
        processed: dict[str, DataFrame],
        *args,
        **kwargs,
    ) -> float:
        """
        自定义目标函数
        返回值越小，策略表现越好
        """

        # 1. 基础指标计算
        total_profit = results['profit_ratio'].sum()  # 总利润
        win_rate = (results['profit_ratio'] > 0).sum() / len(results)  # 胜率
        avg_profit = results['profit_ratio'].mean()  # 平均利润
        max_drawdown = results['max_drawdown'].max()  # 最大回撤

        # 2. 交易频率评估
        days = (max_date - min_date).days
        trades_per_day = trade_count / days if days > 0 else 0

        # 3. 计算各项损失
        # 利润损失：期望利润为正数
        profit_loss = max(0, 1 - total_profit / 2.0)  # 期望总利润至少2.0

        # 胜率损失：期望胜率至少40%
        win_rate_loss = max(0, 1 - win_rate / 0.4)

        # 回撤损失：期望最大回撤不超过15%
        drawdown_loss = max(0, max_drawdown - 0.15) * 2

        # 交易频率损失：期望每天1-5笔交易
        if trades_per_day < 1:
            freq_loss = 1 - trades_per_day  # 交易过少
        elif trades_per_day > 5:
            freq_loss = (trades_per_day - 5) * 0.1  # 交易过多
        else:
            freq_loss = 0

        # 4. 综合评分
        total_loss = (
            profit_loss * 0.4 +      # 利润权重40%
            win_rate_loss * 0.3 +    # 胜率权重30%
            drawdown_loss * 0.2 +    # 回撤权重20%
            freq_loss * 0.1          # 频率权重10%
        )

        return total_loss
```

### 3. 不同策略类型的Loss函数示例

#### 3.1 保守型策略的Loss函数

```python
class ConservativeHyperOptLoss(IHyperOptLoss):
    """
    保守型策略：重点关注回撤控制
    """

    @staticmethod
    def hyperopt_loss_function(results: DataFrame, trade_count: int, *args, **kwargs) -> float:
        total_profit = results['profit_ratio'].sum()
        max_drawdown = results['max_drawdown'].max()
        avg_trade_duration = results['trade_duration'].mean()

        # 重点惩罚高回撤
        drawdown_penalty = max_drawdown * 3  # 回撤权重更高

        # 利润要求不高，但不能亏损
        profit_penalty = max(0, -total_profit) * 2

        # 偏好较长持仓时间（降低交易频率）
        duration_bonus = max(0, avg_trade_duration - 60) * 0.01  # 超过1小时有奖励

        return drawdown_penalty + profit_penalty - duration_bonus
```

#### 3.2 高频交易策略的Loss函数

```python
class HighFrequencyHyperOptLoss(IHyperOptLoss):
    """
    高频策略：重点关注交易频率和滑点成本
    """

    @staticmethod
    def hyperopt_loss_function(results: DataFrame, trade_count: int, *args, **kwargs) -> float:
        total_profit = results['profit_ratio'].sum()
        trade_count_penalty = abs(trade_count - 1000) * 0.001  # 期望1000笔交易

        # 考虑滑点成本（高频交易滑点影响更大）
        avg_profit = results['profit_ratio'].mean()
        slippage_impact = max(0, 0.001 - avg_profit) * 1000  # 单笔利润不能低于0.1%

        # 快速进出（降低持仓风险）
        avg_duration = results['trade_duration'].mean()
        duration_penalty = max(0, avg_duration - 30) * 0.01  # 期望平均30分钟内完成

        return trade_count_penalty + slippage_impact + duration_penalty
```

#### 3.3 趋势跟踪策略的Loss函数

```python
class TrendFollowingHyperOptLoss(IHyperOptLoss):
    """
    趋势跟踪策略：重点关注大趋势和大利润
    """

    @staticmethod
    def hyperopt_loss_function(results: DataFrame, trade_count: int, *args, **kwargs) -> float:
        # 分离大利润交易和小利润交易
        large_profits = results[results['profit_ratio'] > 0.05]  # 大于5%的利润
        small_profits = results[(results['profit_ratio'] > 0) & (results['profit_ratio'] <= 0.05)]

        # 奖励大利润交易
        large_profit_bonus = large_profits['profit_ratio'].sum() * 2

        # 轻微惩罚小利润交易（鼓励大利润）
        small_profit_penalty = small_profits['profit_ratio'].sum() * 0.5

        # 总利润
        total_profit = results['profit_ratio'].sum()

        # 交易频率（趋势策略不需要太频繁）
        freq_penalty = max(0, trade_count - 200) * 0.01

        return -large_profit_bonus + small_profit_penalty - total_profit + freq_penalty
```

### 4. Loss函数调试技巧

```python
def debug_loss_function(results: DataFrame, trade_count: int, *args, **kwargs) -> float:
    """
    调试用的Loss函数，会打印详细信息
    """
    total_profit = results['profit_ratio'].sum()
    win_rate = (results['profit_ratio'] > 0).sum() / len(results)
    max_drawdown = results['max_drawdown'].max()

    print(f"""
    调试信息:
    总利润: {total_profit:.4f}
    胜率: {win_rate:.2%}
    最大回撤: {max_drawdown:.2%}
    交易次数: {trade_count}
    """)

    # 计算各项损失
    profit_loss = max(0, 1 - total_profit / 2.0)
    win_rate_loss = max(0, 1 - win_rate / 0.4)
    drawdown_loss = max(0, max_drawdown - 0.15) * 2

    total_loss = profit_loss + win_rate_loss + drawdown_loss

    print(f"各项损失: 利润={profit_loss:.4f}, 胜率={win_rate_loss:.4f}, 回撤={drawdown_loss:.4f}")
    print(f"总损失: {total_loss:.4f}")

    return total_loss
```

## 🎯 实战案例：从零开始创建策略

### 案例1：双均线策略

```python
class DoubleEMAStrategy(IStrategy):
    """
    双均线交叉策略
    快线上穿慢线：买入
    快线下穿慢线：卖出
    """

    INTERFACE_VERSION = 3
    timeframe = "1h"

    minimal_roi = {
        "1440": 0.02,  # 24小时内获利2%
        "720": 0.03,   # 12小时内获利3%
        "360": 0.04,   # 6小时内获利4%
        "0": 0.06      # 立即获利6%
    }

    stoploss = -0.08

    # 可优化参数
    fast_ema = IntParameter(5, 20, 10, space="buy", optimize=True, load=True)
    slow_ema = IntParameter(20, 50, 30, space="buy", optimize=True, load=True)

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe['fast_ema'] = ta.EMA(dataframe, timeperiod=self.fast_ema.value)
        dataframe['slow_ema'] = ta.EMA(dataframe, timeperiod=self.slow_ema.value)
        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            qtpylib.crossed_above(dataframe['fast_ema'], dataframe['slow_ema']),
            'enter_long'
        ] = 1
        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            qtpylib.crossed_below(dataframe['fast_ema'], dataframe['slow_ema']),
            'exit_long'
        ] = 1
        return dataframe
```

### 案例2：RSI+布林带策略

```python
class RSI_BollingerStrategy(IStrategy):
    """
    RSI + 布林带组合策略
    在布林带下轨附近且RSI超卖时买入
    在布林带上轨附近且RSI超买时卖出
    """

    INTERFACE_VERSION = 3
    timeframe = "30m"

    minimal_roi = {
        "240": 0.015,  # 4小时内获利1.5%
        "120": 0.025,  # 2小时内获利2.5%
        "60": 0.035,   # 1小时内获利3.5%
        "0": 0.055     # 立即获利5.5%
    }

    stoploss = -0.06

    # 可优化参数
    rsi_period = IntParameter(10, 20, 14, space="buy", optimize=True, load=True)
    rsi_buy = IntParameter(20, 35, 30, space="buy", optimize=True, load=True)
    rsi_sell = IntParameter(65, 80, 70, space="sell", optimize=True, load=True)
    bb_window = IntParameter(15, 25, 20, space="buy", optimize=True, load=True)

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # RSI
        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=self.rsi_period.value)

        # 布林带
        bollinger = qtpylib.bollinger_bands(
            qtpylib.typical_price(dataframe),
            window=self.bb_window.value,
            stds=2
        )
        dataframe['bb_upper'] = bollinger['upper']
        dataframe['bb_lower'] = bollinger['lower']
        dataframe['bb_middle'] = bollinger['mid']

        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            (
                (dataframe['rsi'] < self.rsi_buy.value) &
                (dataframe['close'] < dataframe['bb_lower'] * 1.01) &  # 接近下轨1%
                (dataframe['volume'] > 0)
            ),
            'enter_long'
        ] = 1
        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            (
                (dataframe['rsi'] > self.rsi_sell.value) |
                (dataframe['close'] > dataframe['bb_upper'] * 0.99)  # 接近上轨1%
            ),
            'exit_long'
        ] = 1
        return dataframe
```

## 📋 总结

### 策略编写核心要点

1. **继承基础**：从 `IStrategy` 继承
2. **参数定义**：明确区分必要参数和自定义参数
3. **方法实现**：必须实现三个核心方法
4. **参数优化**：使用 `Parameter` 类定义可优化参数
5. **信号逻辑**：清晰的买入和卖出条件
6. **风险控制**：合理的止损和收益目标

### Loss函数设计原则

1. **目标明确**：根据策略特点选择合适的优化目标
2. **权重平衡**：合理分配各项指标的权重
3. **风险意识**：重视回撤控制
4. **实用性**：考虑实际交易成本和限制
5. **可调试**：便于分析和调整

### 最佳实践建议

1. **从小开始**：从简单策略开始，逐步增加复杂度
2. **充分回测**：在不同市场条件下测试策略
3. **参数优化**：使用Hyperopt找到最佳参数组合
4. **风险控制**：始终把风险管理放在首位
5. **持续改进**：根据实盘表现调整策略

---

**💡 记住**：策略编写是一个迭代过程。不要期望第一次就能写出完美的策略，通过不断的测试、优化和改进，才能打造出真正适合自己的交易策略！
